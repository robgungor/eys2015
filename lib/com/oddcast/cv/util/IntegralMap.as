package com.oddcast.cv.util{	import flash.display.BitmapData;		import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.ByteArray;		final public class IntegralMap	{			public var sum:Vector.<Number>;						public var width:int;		public var height:int;				private var padded:BitmapData			//	private var bd:BitmapData				private var paddedPoint:Point				private var pixelCount:int		//private var zero:Point		private var rect:Rectangle		private var i_m:Vector.<Number>;								/**		 * Construct an IntegralMap from a BitmapData		 		 */		public function IntegralMap(bd:BitmapData)		{			paddedPoint = new Point(1, 1);		}				private function checkSizeChanged(bd:BitmapData):void {			if ((bd.width+ 1 != width )  &&			     (bd.height + 1 != height)) {					 				width = bd.width+1;				height = bd.height+1;				trace(width+":"+height)				pixelCount = width * height;				sum = new Vector.<Number>(pixelCount, true);			 				padded = new BitmapData(width,height, false, 0x00000000 ); //fill with zeros										rect=padded.rect				i_m = new Vector.<Number>(pixelCount, true);			 }		}								private function extractGrayScaleByteArray(bd:BitmapData) :void{			//padded.applyFilter(bd, bd.rect, paddedPoint);			padded.copyPixels(bd, bd.rect, paddedPoint);		}		/* 		private function  extractBlueChannel(bd:BitmapData, justRectPadded:Rectangle):void {			var ba:ByteArray = padded.getPixels(justRectPadded);			ba.position = 0;			var normalizer:Number = 1 / 255;						var farY:int = justRectPadded.bottom;			var farX:int = justRectPadded.right;			var offset:int = justRectPadded.y * width + justRectPadded.x;	   			var rectWidth:int = justRectPadded.width;						for (var y:int = justRectPadded.y;  y < farY; y++) {				    					for (var x :int = justRectPadded.x;  x < farX; x++) {						i_m[offset++] = (ba.readUnsignedInt()  & 0x000000ff) * normalizer;					}					offset += (width - rectWidth);			}		}*/				 // wont run in the profiler!	  private function  extractBlueChannel(bd:BitmapData, justRectPadded:Rectangle):void {			var iPadded:Vector.<uint> = padded.getVector(justRectPadded);						var normalizer:Number = 1 / 255;					var farY:int = justRectPadded.bottom;			var farX:int = justRectPadded.right;			var offset:int = justRectPadded.y * width + justRectPadded.x;		    var i:int = 0;			var rectWidth:int = justRectPadded.width;			for (var y:int = justRectPadded.y;  y < farY; y++) {				    					for (var x :int = justRectPadded.x;  x < farX; x++) {						i_m[offset++] = (iPadded[i++] & 0x000000ff) * normalizer;					}					offset += (width - rectWidth);			}		}				public  function update(bd:BitmapData, justRectBD:Rectangle):void		{			checkSizeChanged(bd);			extractGrayScaleByteArray(bd);						var justRectPadded:Rectangle =  justRectBD.clone();			justRectPadded.x += 1.0;			justRectPadded.y += 1.0;						extractBlueChannel(bd, justRectPadded);						sum[0] = 0;						 			/*var px:int			var pimx:Number					for (var x:int = 1; x < width; x++)			{				px=x-1				pimx = i_m[x]; // as Number				sum[x] = sum[px] + pimx;				sqsum[x] = sqsum[px] + pimx * pimx;			}*/			var r:Number;			var rs:Number;						var yx:int			var yyx:int			var imy:Number			var top:int = justRectPadded.y;			var bottom:int  = justRectPadded.bottom;			var left :int = justRectPadded.x;			var right:int = justRectPadded.right;						var YY:int = (top-1)*width;			var Y:int =    YY + width;						for (var y:int = top;     y < bottom;     y++)			{				r = 0;								for (var x:int = left; x < right; x++)				{					yx=Y+x					yyx=YY+x					imy = i_m[yx]; // as Number;					r += imy;					sum[yx] = sum[yyx] + r;						} 				Y += width;				YY += width			}		}					public function getRectSum(r:Rectangle):Number		{			var rx:int = r.x;			var ry:int = r.y;			var rw:int = r.width;			var rh:int = r.height;									var c:int = (ry + rh) * width + rx;			var a:int = c+ rw;						var d:int = (ry * width) + rx;			var b:int = d + rw;					return sum[a] - sum[b] - sum[c] + sum[d];		}						public function getSum(rx:int ,ry:int, rw:int, rh:int):Number{									var c:int = (ry + rh) * width + rx;			var a:int = c+ rw;						var d:int = (ry * width) + rx;			var b:int = d + rw;					return sum[a] - sum[b] - sum[c] + sum[d];		}										/*public function evaluateSubImageNext(haarRect:HaarRect ):Number		{						var ret:Number = 0.0;			if (haarRect.next)				ret = evaluateSubImageNext(haarRect.next);						var rw :int	= (haarRect.origW * scale256)>>8;			var rh :int	= (haarRect.origH * scale256)>>8;				var rx 	:int = irx + ((haarRect.origX * scale256)>>8);			var ry 	:int = iry + ((haarRect.origY * scale256)>>8);						var d:int = (ry * width) + rx;			var b:int =  d + rw;				var c:int = (ry + rh) * width + rx;			var a:int =  c + rw;						var total:Number = sum[a] - sum[b] - sum[c] + sum[d];						return ret + haarRect.weight * total;							}*/					}}